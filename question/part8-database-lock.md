1. 비관적 락과 낙관적 락에 관해서 설명해주세요.

> 문진수
>
> 비관적 락의 경우 SELECT FOR UPDATE로 DB 레코드에 다이렉트로 Lock을 잡는 방식입니다. Lock을 시도하는 TX가 많아지면 그만큼 지연이 발생하고 성능상 저하가 발생할 수 있습니다. 낙관적 락은 Versioning 방식으로 동작하며 Update 시점과 조회 시점의 버전 값을 비교하여 같으면 수정하고 다르면 재시도하는 방식입니다. 충돌이 많이 발생하면 재시도를 하게 되기 때문에 충돌 가능성이 적을 때 쓰면 좋습니다.

---
2. 네임드 락에 관해서 설명해주세요.

> 문진수
>
> 네임드락은 DB 메타데이터에 락을 잡는 방식입니다. 기본적으로 락을 잡는 TX와 로직을 실행하는 TX가 분리되어야 하기 떄문에 커넥션을 2개 잡아먹습니다. 네임드 락을 많이 사용하면 커넥션 고갈이 발생할 수 있습니다.

---
3. 분산 락에 관해서 설명해주세요.

> 문진수
>
> 분산락이란 다수의 서버가 동시에 동일한 자원에 접근하려 할 때 발생할 수 있는 동시성 문제를 해결하기 위한 동기화 메커니즘입니다. Redis를 이용한 분산락에서 자주 사용되는 SETNX 명령어는 해당 키가 존재하지 않을 때만 값을 설정합니다. 즉 키가 없으면 값을 세팅하고 1을 반환하며 이미 존재하면 아무 작업도 하지 않고 0을 반환합니다. Redis는 싱글 스레드 기반으로 동작하기 때문에 이러한 명령어들은 원자적으로 실행됩니다. 따라서 동시에 여러 클라이언트가 같은 락을 요청하더라도 한 번에 하나의 요청만 성공하고 나머지는 실패하게 되어 락의 동시 접근 문제가 없습니다.

---
4. Java의 애플리케이션 레벨에서 Synchronized 방식으로 동시성 제어를 하면 어떤 장단점이 있을까요?

> 문진수
>
> 간단하게 블록을 통해 적용이 가능하다는 장점이 있습니다. 하지만 락을 획득하지 못한 스레드는 WAITING 상태가 아닌 BLOCKED 상태로 바뀌기 때문에 상황에 따라 무기한 대기를 하게 될 수도 있습니다. 그리고 타임아웃 설정도 불가능합니다. 좀 더 세밀한 제어가 필요하거나 공정성이 필요하다면 ReentrantLock을 사용하는게 더 좋습니다. 그리고 인스턴스 수준의 락이기 때문에 다중 WAS 환경에서는 제대로 동작하지 않을 수 있습니다.

---
5. 데이터베이스에서의 공유 락과 베타 락에 관해서 설명해주세요. 동시에 여러 세션이 공유 락 혹은 베타 락을 잡는 것이 가능한가요?

> 문진수
>
> 공유락은 여러 세션이 동시에 획득이 가능합니다. 반면 배타락은 다른 세션의 공유락이나 배타락과 동시에 존재할 수 없습니다.