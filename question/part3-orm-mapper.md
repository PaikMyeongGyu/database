1. preparestatement를 써보신 적이 있으실까요? 해당 쿼리문의 장점이 무엇인가요?

> 문진수
>
> preparestatement를 사용하면 값을 파라미터로 전달하여 동적으로 SQL을 생성하는 대신에 미리 정의된 SQL에 값을 채워넣을 수 있어서 SQL Injection을 방지할 수 있습니다. 그리고 쿼리를 컴파일 후 실행 계획을 재사용하여 성능을 향상시킬 수 있습니다. 그 뿐만 아니라 쿼리와 파라미터가 분리되어 코드 가독성, 유지보수성을 향상시킬 수 있습니다.

---
2. MyBatis랑 JPA 중 써보신 적이 있는 기술에 관해서 말씀해주시고. 어떤 장단점이 있는지 말씀해주세요.

> 문진수
>
> 둘 다 사용해봤는데 MyBatis 같은 경우 XML을 통해 작성되고 native query를 짜듯이 개발할 수 있어서 좋았습니다. 그리고 동적 쿼리도 편리하게 작성할 수 있고 성능도 쌩쿼리와 같기 때문에 좋습니다. JPA의 경우 러닝 커브가 높은 편이지만 개발 속도가 확실히 빨라지는 것을 느꼈습니다. 영속성 컨텍스트를 통해 1차 캐시, 더티 채킹 기능을 제공하기 때문에 굉장히 편리합니다. 복잡한 쿼리의 경우 JPQL로 해결할 수 없는 경우도 존재하기 때문에 native query를 섞어서 작성하면 좋습니다.

---
3. 데이터베이스의 옵티마이저에 관해서 설명해주세요.

> 문진수
>
> MySQL 서버에서 담당하는 기능으로 사용자의 SQL 쿼리를 수행할 수 있는 많은 방법 중에서 최적의 실행 계획을 찾아내는 역할을 수행합니다. SQL 파싱 트리를 확인하면서 어떤 테이블부터 읽을지, 어떤 인덱스를 사용할 지 실행 계획을 생성합니다. 최신 옵티마이저는 RBO를 사용하지 않고 CBO를 사용하여 비용 기반 최적화를 수행합니다. 이 때 테이블 레코드 개수, 칼럼의 카디널리티 등이 고려 대상이 됩니다.

---
4. JPA에서의 N + 1 문제에 대해서 설명해주세요.

> 문진수
>
> 연관관계가 설정된 엔티티를 조회할 때 추가로 N개의 쿼리가 더 나가는 문제를 뜻합니다. JPA의 경우 연관관계로 설정된 객체를 프록시로 관리하는데 프록시의 실제 필드 값이 조회될 때마다 쿼리가 추가로 발생하게 됩니다. 즉 1:N 관계에서 N에 해당하는 객체의 필드를 조회할 때마다 쿼리가 추가로 하나씩 나갑니다.

---