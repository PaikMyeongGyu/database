1. 서브 쿼리의 종류와 각각의 서브쿼리는 어떤 절에 사용할 수 있는지 설명해주세요.

> 문진수
>
> 서브쿼리에는 Nested Subquery, Inline View, Scalar Subquery가 있습니다. Nested Subquery의 경우 WHERE절에서 사용하는 서브 쿼리로 =, IN, ANY등 결과를 다양하게 사용할 수 있습니다. Inline View의 경우 FROM 절의 서브 쿼리로 임시적으로 테이블을 생성하여 해당 테이블로부터 조회를 수행합니다. Scalar Subquery의 경우 SELECT 절에서 사용되며 반드시 단 하나의 레코드만 결과로 나와야 합니다.

---
2. Full Table Scan과 Index range Scan의 차이는 무엇인가요? 상황 별 스캔이 유리한 경우에 관해서 말씀해주세요.

> 문진수
>
> Full Table Scan의 경우 테이블의 모든 레코드를 가져오는 것을 말합니다. 하나의 페이지에 모든 데이터가 들어있거나 조회되는 레코드의 개수가 너무 많은 경우 (25%정도 이상), 그리고 적절히 사용할 인덱스가 없는 경우 Full Table Scan이 실행 계획으로 잡힙니다. InnoDB는 Read-ahead 기능을 제공하는데 Full Table Scan을 할 때 점진적으로 백그라운드 스레드가 페이지를 계속 버퍼 풀에 적재합니다. 포그라운드 스레드는 버퍼 풀에서 데이터만 읽어서 응답해주게 됩니다. Index Range Scan은 인덱스를 사용할 수 있을 때 실행계획으로 잡히게 되고 인덱스 선두 컬럼이 반드시 조건절에 존재해야 합니다. 그리고 Secondary Index의 경우 리프 노드에 PK를 가지는데 이 순서는 해당 인덱스를 기준으로 정렬되기 때문에 레코드를 가져올 때는 각각의 데이터 조회마다 DIsk Random I/O가 발생하게 됩니다. 때문에 너무 많은 레코드를 조회하게 되면 Index를 사용하지 않고 Full Table Scan으로 실행 계획이 잡힙니다.

---
3. 커버링 인덱스에 대해서 설명해주세요.

> 문진수
>
> 쿼리에 필요한 모든 데이터가 인덱스에 포함되어 인덱스만으로 필요 사항을 만족시킬 수 있을 때 해당 인덱스를 커버링 인덱스라고 합니다. 커버링 인덱스로 처리될 경우 데이터에 접근하기 위한 추가적인 디스크 I/O가 발생하지 않기 때문에 속도가 빠릅니다.

---
4. Like 절로 조회를 해오려고 합니다. 이 때, Like 절로 조회한 데이터가 인덱스를 타지 못하는 경우에 대해서 설명해주세요.

> 문진수
>
> B Tree는 인덱스 왼쪽 컬럼을 기준으로 뒤의 값이 정렬됩니다. 때문에 %string과 같이 왼쪽 값으로 결정할 수 없는 경우에는 인덱스를 사용할 수 없습니다.

---